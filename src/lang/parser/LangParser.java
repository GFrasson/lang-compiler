package lang.parser;

import lang.ast.*;
import java.io.IOException;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "lang.grammar".
 */
public class LangParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjbdcKrbKPnx$tleCWZJWw30WQiaSsbfC2mwAC3gY824WcGLfgM8gPP5HafkQuP2b8ueA" +
		"82o0YYAYbcIsQYb6fcHLMqc8BcRHePLRQxNFlxtb$x##THO$7Spp#uVkUxttMk$tkS#$pI7" +
		"whvkf87QDfUe#Eqdjrj6RfVVfWvzhmFStMEpH5CtI49kaGJGx$LNsNlgzYv3UrRtZjXMfJF" +
		"$K8Bsbt3KLgK1$rrMxXHUGBDOp8U7SM6M4xqjkrZqRgqpeZF5CbRLThHL9trQctMiEAB9gG" +
		"n#f0HjjHyqtJ6ZLXMtX4vsXNB2iOhT5iDScxCjemTTCEz7WBViqQNR3iQprsIZs6QGvUipN" +
		"68hdYLvZJ#9sHUX7Z7p2vLx9ziifpjZvgEtyUpK2x6VzCjW$fmzh3l4z9cbPzHitXRrggUP" +
		"MUvd5ByfYZ2$Wcz#aYtM0xEaK3LD9LDl9pXVLbA$2CrA9nQGtBDDXiRxFLjJ37$ioHSJCq0" +
		"UuWctUs9kRSmJbtQCuTbdEnxzJ4JSzrCtFkMEFwmPzWl4K8cfDplu$dtCAS#spEVJxdpi$7" +
		"UwlwQo$eb$BnohIVBb6jcg3NTx2ryU#fqtMkHl2$GeCqd9WOmZ$xDjSHJRleB9sfZ#bKVLc" +
		"NQaxuZTPhJotNrVGz3tkRRjBUz6hJk$GftQZLsa$ZTRYkJErnHEudw7LDU5ZdXE$YjrGBj0" +
		"pj$F07NGjT1LQ4NskK5d6cxm$tQXsQ0nZr0Fx7wqHzH2U5pM6vJjFdTBQ#m2nVr69Tfel3G" +
		"reIleryUVXh#Bsk2SzgPVWLQrgZjRJnTxCSvrxY5iGOwQuUt9gUn7xdsbfkpTvw9plPXrlG" +
		"YxWMtwGhtrSpyflQDxwsaJlHbnDtt1R7ZHf0d0zCikC5haH67wHuh$hpfk$HGV85QJYl$Rv" +
		"eQYsQXdERTasZDPZ69qrytnjuFnrjNUuzCjagezLn7oRGemz#zVIeMCezHjbeW$6ghBVYLv" +
		"mpuuSYEMAyF89Bja5LdiMTUqRFR7tCSnpVCjEq98rdPVLfXuCwtAPiHuFnyEINSSoMxQY5#" +
		"LjvlpAlsiBwiXNCA8nqD3CNLr2nl1vStm9VZf3NDjw1d5e9EYKVhqpxKbbCJBQP7MoD$8ya" +
		"NuqbLfjuQVVZNqys7stVfZb5o6GoqpGoqU7afC5yrp5aj4bai4QoUJrj0tqZZV5#2FciYMm" +
		"uWeecjZ5oZqYzOcp6CssWpedQ6AEHPdnyCuVWvpZHg1c2BcQGUbPUIrlBVt$wZqLsoNiyKc" +
		"#yUwSxLyU$6VtGv3qcndRWXonjE3izucutcZsX0wDSHhoOO2nO36QQxdAZysY2v4yoUNwnR" +
		"sV0PmDu63m4re4hGJrutEpzZGu2Mohz$3IQHdHJmQ7cSvJPZg4PZNmYiBNu9V2pCfuJaLi8" +
		"fQy$3JeBkXHwWespcUPK47CHVkuiQ9lrNMHqcOrxEirgw1MctsXwzg5xeFEwthi$4znX$JO" +
		"npmMchmDhqud8NMAwhzFqXDuEriC$XcsvsRu2FmhwLN2PZVSakaSxdrVRiAqs$Zdu2VIxrS" +
		"QwsFGleTzgkkFXUu0xJVuEpK1etDyYKDRV1Hx4Rmqqucwms6oSiR$K#7j1CtwSWxyFbB$bU" +
		"72$ySI3tmWE1fo1vqpyAhDj0Ly3Xu5DrNjpDeSRqSKttxtWsrBWT#hC$#N0M3iRdMHqGk4R" +
		"FsswblRzEDPdp7QiqUCA$LumtLoZvnNMEDteNKOVCBgvuFE8qVBzUSAedQLxgk2xhS1lB$3" +
		"FljBU2xxFLtX$CfYExiLsFWiAFjsgRRwfk4zepwxdohwtyRt1o89yaT5#xVeCQBUM9QRViP" +
		"tVSZ2g8Dizy2lR#Iq0hSQNutPX9siz0qmrVaKxMrkrh0soN$XV#4$uToxz0$pB#B#3hU79y" +
		"8lmy$2py4JO4bvGrI$y2VmvSJyDVycrFm4$pgN7K$iZaxu5lW7kJXAtDzm9U4K2Bqgu8toJ" +
		"zfx0JGkt1zwVS5lO66uD6y8jONrO5sv6SttgkHRSbBXLOMLXHQjpxbfmTRWkt1ZMX1iod$2" +
		"OsNu07WKFXX#QvlkLKSAcgZtoyeG7mlq5pH$1xyBJLLvF6Vrb#6ryGpMNIiS1JrKZuAXe79" +
		"LHXea9djmk4EkZRjG7DLG90Yvc2#38A16Uh2$WgA9waDaTyEHt0KSUBv5PFPazPdTFVXTmL" +
		"1CrvDaQidK9E79sHpHXQsBk9YhaZ9OI9cERp5YyTY3wrIICGuxrt1JebAJVWOploVMUwiC1" +
		"7pCSS5GrDTG$9U2eWae6HprK0ewggDG9lC6z34fKB0BbCRfJiPJ8pB7Eg04bgY47F3MHWAF" +
		"oz5GdNhF#3nigioq=");

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

  private boolean good;
          
  public boolean isGood() { return good; }
          
  protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception {
    super.recoverFromError(token, in);
    good = false;
  }

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$Def = Def
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$Def = lst$Def Def
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [2] opt$lst$Def = 
			Action.RETURN,	// [3] opt$lst$Def = lst$Def
			new Action() {	// [4] Prog = opt$lst$Def.def
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_def = _symbols[offset + 1];
					final ArrayList _list_def = (ArrayList) _symbol_def.value;
					final Node[] def = _list_def == null ? new Node[0] : (Node[]) _list_def.toArray(new Node[_list_def.size()]);
					 return Program(def.data, def.fun);
				}
			},
			new Action() {	// [5] Def = Data.data
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_data = _symbols[offset + 1];
					final Node data = (Node) _symbol_data.value;
					 return data;
				}
			},
			new Action() {	// [6] Def = Fun.fun
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_fun = _symbols[offset + 1];
					final Node fun = (Node) _symbol_fun.value;
					 return fun;
				}
			},
			new Action() {	// [7] lst$Decl = Decl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [8] lst$Decl = lst$Decl Decl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [9] opt$lst$Decl = 
			Action.RETURN,	// [10] opt$lst$Decl = lst$Decl
			new Action() {	// [11] Data = DATA TYPE_NAME.typeName OPEN_CURLY_BRACE opt$lst$Decl.decl CLOSE_CURLY_BRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol typeName = _symbols[offset + 2];
					final Symbol _symbol_decl = _symbols[offset + 4];
					final ArrayList _list_decl = (ArrayList) _symbol_decl.value;
					final Node[] decl = _list_decl == null ? new Node[0] : (Node[]) _list_decl.toArray(new Node[_list_decl.size()]);
					 return ;
				}
			},
			new Action() {	// [12] Decl = ID.id DOUBLE_COLON Type SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return ;
				}
			},
			Action.NONE,  	// [13] opt$Params = 
			Action.RETURN,	// [14] opt$Params = Params
			Action.NONE,  	// [15] opt$ReturnType = 
			Action.RETURN,	// [16] opt$ReturnType = ReturnType
			new Action() {	// [17] lst$Cmd = Cmd
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [18] lst$Cmd = lst$Cmd Cmd
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [19] opt$lst$Cmd = 
			Action.RETURN,	// [20] opt$lst$Cmd = lst$Cmd
			new Action() {	// [21] Fun = ID.id OPEN_PARENTHESIS opt$Params.params CLOSE_PARENTHESIS opt$ReturnType.returnType OPEN_CURLY_BRACE opt$lst$Cmd.cmd CLOSE_CURLY_BRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_params = _symbols[offset + 3];
					final Node params = (Node) _symbol_params.value;
					final Symbol _symbol_returnType = _symbols[offset + 5];
					final Tipo[] returnType = (Tipo[]) _symbol_returnType.value;
					final Symbol _symbol_cmd = _symbols[offset + 7];
					final ArrayList _list_cmd = (ArrayList) _symbol_cmd.value;
					final Node[] cmd = _list_cmd == null ? new Node[0] : (Node[]) _list_cmd.toArray(new Node[_list_cmd.size()]);
					 return new Function(id, params, returnType, cmd);
				}
			},
			new Action() {	// [22] lst$TypeList = TypeList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [23] lst$TypeList = lst$TypeList TypeList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [24] opt$lst$TypeList = 
			Action.RETURN,	// [25] opt$lst$TypeList = lst$TypeList
			RETURN3,	// [26] ReturnType = COLON Type.type opt$lst$TypeList.typeList; returns 'typeList' although more are marked
			RETURN2,	// [27] TypeList = COMMA Type; returns 'Type' although none is marked
			new Action() {	// [28] lst$ParamsTypeList = ParamsTypeList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [29] lst$ParamsTypeList = lst$ParamsTypeList ParamsTypeList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [30] opt$lst$ParamsTypeList = 
			Action.RETURN,	// [31] opt$lst$ParamsTypeList = lst$ParamsTypeList
			new Action() {	// [32] Params = ID.id DOUBLE_COLON Type.type opt$lst$ParamsTypeList.paramsTypeList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 3];
					final Node type = (Node) _symbol_type.value;
					final Symbol paramsTypeList = _symbols[offset + 4];
					 return ;
				}
			},
			RETURN4,	// [33] ParamsTypeList = COMMA ID DOUBLE_COLON Type; returns 'Type' although none is marked
			new Action() {	// [34] Type = Type.type OPEN_BRACKET CLOSE_BRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type = _symbols[offset + 1];
					final Node type = (Node) _symbol_type.value;
					 return ;
				}
			},
			new Action() {	// [35] Type = BType.bType
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_bType = _symbols[offset + 1];
					final Node bType = (Node) _symbol_bType.value;
					 return ;
				}
			},
			new Action() {	// [36] BType = TYPE_INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return ;
				}
			},
			new Action() {	// [37] BType = TYPE_CHAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return ;
				}
			},
			new Action() {	// [38] BType = TYPE_BOOL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return ;
				}
			},
			new Action() {	// [39] BType = TYPE_FLOAT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return ;
				}
			},
			new Action() {	// [40] BType = TYPE_NAME.typeName
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol typeName = _symbols[offset + 1];
					 return ;
				}
			},
			new Action() {	// [41] Cmd = OPEN_CURLY_BRACE opt$lst$Cmd.cmd CLOSE_CURLY_BRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_cmd = _symbols[offset + 2];
					final ArrayList _list_cmd = (ArrayList) _symbol_cmd.value;
					final Node[] cmd = _list_cmd == null ? new Node[0] : (Node[]) _list_cmd.toArray(new Node[_list_cmd.size()]);
					 return ;
				}
			},
			new Action() {	// [42] Cmd = IF OPEN_PARENTHESIS Exp.exp CLOSE_PARENTHESIS Cmd.cmd
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Expression exp = (Expression) _symbol_exp.value;
					final Symbol _symbol_cmd = _symbols[offset + 5];
					final Node cmd = (Node) _symbol_cmd.value;
					 return ;
				}
			},
			new Action() {	// [43] Cmd = IF OPEN_PARENTHESIS Exp.exp CLOSE_PARENTHESIS Cmd.cmd ELSE Cmd.cmd
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Expression exp = (Expression) _symbol_exp.value;
					final Symbol _symbol_cmd = _symbols[offset + 5];
					final Node cmd = (Node) _symbol_cmd.value;
					final Symbol _symbol_cmd = _symbols[offset + 7];
					final Node cmd = (Node) _symbol_cmd.value;
					 return ;
				}
			},
			new Action() {	// [44] Cmd = ITERATE OPEN_PARENTHESIS Exp.exp CLOSE_PARENTHESIS Cmd.cmd
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Expression exp = (Expression) _symbol_exp.value;
					final Symbol _symbol_cmd = _symbols[offset + 5];
					final Node cmd = (Node) _symbol_cmd.value;
					 return ;
				}
			},
			new Action() {	// [45] Cmd = READ LValue.lValue SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lValue = _symbols[offset + 2];
					final Node lValue = (Node) _symbol_lValue.value;
					 return ;
				}
			},
			new Action() {	// [46] Cmd = PRINT Exp.exp SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Expression exp = (Expression) _symbol_exp.value;
					 return ;
				}
			},
			new Action() {	// [47] lst$CmdExpList = CmdExpList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [48] lst$CmdExpList = lst$CmdExpList CmdExpList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [49] opt$lst$CmdExpList = 
			Action.RETURN,	// [50] opt$lst$CmdExpList = lst$CmdExpList
			new Action() {	// [51] Cmd = RETURN Exp.exp opt$lst$CmdExpList SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Expression exp = (Expression) _symbol_exp.value;
					 return ;
				}
			},
			new Action() {	// [52] Cmd = LValue.lValue EQUAL Exp.exp SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lValue = _symbols[offset + 1];
					final Node lValue = (Node) _symbol_lValue.value;
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Expression exp = (Expression) _symbol_exp.value;
					 return ;
				}
			},
			Action.NONE,  	// [53] opt$Exps = 
			Action.RETURN,	// [54] opt$Exps = Exps
			Action.NONE,  	// [55] opt$ReturnParams = 
			Action.RETURN,	// [56] opt$ReturnParams = ReturnParams
			new Action() {	// [57] Cmd = ID OPEN_PARENTHESIS opt$Exps.exps CLOSE_PARENTHESIS opt$ReturnParams.returnParams SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exps = _symbols[offset + 3];
					final Node exps = (Node) _symbol_exps.value;
					final Symbol returnParams = _symbols[offset + 5];
					 return ;
				}
			},
			RETURN2,	// [58] CmdExpList = COMMA Exp.exp
			RETURN2,	// [59] LValueList = COMMA LValue.lvalue
			new Action() {	// [60] lst$LValueList = LValueList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [61] lst$LValueList = lst$LValueList LValueList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [62] opt$lst$LValueList = 
			Action.RETURN,	// [63] opt$lst$LValueList = lst$LValueList
			RETURN2,	// [64] ReturnParams = LESS_THAN LValue.lvalue opt$lst$LValueList GREATER_THAN
			new Action() {	// [65] Exp = Exp.expLeft AND Exp2.expRight
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_expLeft = _symbols[offset + 1];
					final Expression expLeft = (Expression) _symbol_expLeft.value;
					final Symbol expRight = _symbols[offset + 3];
					 return new And(expLeft, expRight);
				}
			},
			Action.RETURN,	// [66] Exp = Exp2
			new Action() {	// [67] Exp2 = Exp2.expLeft COMPARISON Exp3.expRight
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol expLeft = _symbols[offset + 1];
					final Symbol expRight = _symbols[offset + 3];
					 return new Equals(expLeft, expRight);
				}
			},
			new Action() {	// [68] Exp2 = Exp2.expLeft NOT_EQUAL Exp3.expRight
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol expLeft = _symbols[offset + 1];
					final Symbol expRight = _symbols[offset + 3];
					 return new NotEqual(expLeft, expRight);
				}
			},
			Action.RETURN,	// [69] Exp2 = Exp3
			new Action() {	// [70] Exp3 = Exp3.expLeft LESS_THAN Exp4.expRight
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol expLeft = _symbols[offset + 1];
					final Symbol expRight = _symbols[offset + 3];
					 return new LessThan(expLeft, expRight);
				}
			},
			Action.RETURN,	// [71] Exp3 = Exp4
			new Action() {	// [72] Exp4 = Exp.expLeft PLUS Exp.expRight
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_expLeft = _symbols[offset + 1];
					final Expression expLeft = (Expression) _symbol_expLeft.value;
					final Symbol _symbol_expRight = _symbols[offset + 3];
					final Expression expRight = (Expression) _symbol_expRight.value;
					 return new Add(expLeft, expRight);
				}
			},
			new Action() {	// [73] Exp4 = Exp.expLeft MINUS Exp.expRight
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_expLeft = _symbols[offset + 1];
					final Expression expLeft = (Expression) _symbol_expLeft.value;
					final Symbol _symbol_expRight = _symbols[offset + 3];
					final Expression expRight = (Expression) _symbol_expRight.value;
					 return new Minus(expLeft, expRight);
				}
			},
			new Action() {	// [74] Exp4 = Exp.expLeft TIMES Exp.expRight
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_expLeft = _symbols[offset + 1];
					final Expression expLeft = (Expression) _symbol_expLeft.value;
					final Symbol _symbol_expRight = _symbols[offset + 3];
					final Expression expRight = (Expression) _symbol_expRight.value;
					 return new Multiplication(expLeft, expRight);
				}
			},
			new Action() {	// [75] Exp4 = Exp.expLeft DIVISION Exp.expRight
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_expLeft = _symbols[offset + 1];
					final Expression expLeft = (Expression) _symbol_expLeft.value;
					final Symbol _symbol_expRight = _symbols[offset + 3];
					final Expression expRight = (Expression) _symbol_expRight.value;
					 return new Division(expLeft, expRight);
				}
			},
			new Action() {	// [76] Exp4 = Exp.expLeft MODULUS Exp.expRight
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_expLeft = _symbols[offset + 1];
					final Expression expLeft = (Expression) _symbol_expLeft.value;
					final Symbol _symbol_expRight = _symbols[offset + 3];
					final Expression expRight = (Expression) _symbol_expRight.value;
					 return new Modulus(expLeft, expRight);
				}
			},
			new Action() {	// [77] Exp4 = NOT Exp.exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Expression exp = (Expression) _symbol_exp.value;
					 return new Not(exp);
				}
			},
			new Action() {	// [78] Exp4 = MINUS Exp.exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Expression exp = (Expression) _symbol_exp.value;
					 return new UnaryMinus(exp);
				}
			},
			new Action() {	// [79] Exp4 = FALSE.false
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_false = _symbols[offset + 1];
					final Boolean false = (Boolean) _symbol_false.value;
					 return new False();
				}
			},
			new Action() {	// [80] Exp4 = TRUE.true
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_true = _symbols[offset + 1];
					final Boolean true = (Boolean) _symbol_true.value;
					 return new True();
				}
			},
			new Action() {	// [81] Exp4 = NULL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Null();
				}
			},
			new Action() {	// [82] Exp4 = INT.literalInt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_literalInt = _symbols[offset + 1];
					final Integer literalInt = (Integer) _symbol_literalInt.value;
					 return new LiteralInt(literalInt);
				}
			},
			new Action() {	// [83] Exp4 = FLOAT.literalFloat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_literalFloat = _symbols[offset + 1];
					final Float literalFloat = (Float) _symbol_literalFloat.value;
					 return new LiteralFloat(literalFloat);
				}
			},
			new Action() {	// [84] Exp4 = CHAR.literalChar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_literalChar = _symbols[offset + 1];
					final Character literalChar = (Character) _symbol_literalChar.value;
					 return new LiteralChar(literalChar);
				}
			},
			new Action() {	// [85] Exp4 = LValue.lValue
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lValue = _symbols[offset + 1];
					final Node lValue = (Node) _symbol_lValue.value;
					 return lValue;
				}
			},
			new Action() {	// [86] Exp4 = OPEN_PARENTHESIS Exp.exp CLOSE_PARENTHESIS
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Expression exp = (Expression) _symbol_exp.value;
					 return exp;
				}
			},
			Action.NONE,  	// [87] opt$VectorDef = 
			Action.RETURN,	// [88] opt$VectorDef = VectorDef
			new Action() {	// [89] Exp4 = NEW Type.type opt$VectorDef.vectorDef
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type = _symbols[offset + 2];
					final Node type = (Node) _symbol_type.value;
					final Symbol vectorDef = _symbols[offset + 3];
					 return ;
				}
			},
			new Action() {	// [90] Exp4 = ID.id OPEN_PARENTHESIS opt$Exps.arguments CLOSE_PARENTHESIS OPEN_BRACKET Exp.returnIndex CLOSE_BRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_arguments = _symbols[offset + 3];
					final Node arguments = (Node) _symbol_arguments.value;
					final Symbol _symbol_returnIndex = _symbols[offset + 6];
					final Expression returnIndex = (Expression) _symbol_returnIndex.value;
					 return new Call(id, arguments, returnIndex);
				}
			},
			new Action() {	// [91] VectorDef = OPEN_BRACKET Exp.exp CLOSE_BRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Expression exp = (Expression) _symbol_exp.value;
					 return exp;
				}
			},
			new Action() {	// [92] LValue = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return ;
				}
			},
			new Action() {	// [93] LValue = LValue.lValue OPEN_BRACKET Exp.exp CLOSE_BRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lValue = _symbols[offset + 1];
					final Node lValue = (Node) _symbol_lValue.value;
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Expression exp = (Expression) _symbol_exp.value;
					 return ;
				}
			},
			new Action() {	// [94] LValue = LValue.lValue DOT ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lValue = _symbols[offset + 1];
					final Node lValue = (Node) _symbol_lValue.value;
					final Symbol id = _symbols[offset + 3];
					 return ;
				}
			},
			new Action() {	// [95] lst$ExpList = ExpList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [96] lst$ExpList = lst$ExpList ExpList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [97] opt$lst$ExpList = 
			Action.RETURN,	// [98] opt$lst$ExpList = lst$ExpList
			new Action() {	// [99] Exps = Exp.exp opt$lst$ExpList.expList
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Expression exp = (Expression) _symbol_exp.value;
					final Symbol expList = _symbols[offset + 2];
					 return ;
				}
			},
			RETURN2	// [100] ExpList = COMMA Exp.exp
		};

 good = true;
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
