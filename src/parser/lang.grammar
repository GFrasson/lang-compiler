%package "parser";
%import "ast.*";
%import "java.io.IOException";

%class "LangParser";

%terminals INT, FLOAT, BOOLEAN,
    NULL, IF, ELSE, DATA, ITERATE, RETURN, PRINT, READ, NEW,
    ID, TYPE_NAME, CHAR, 
    OPEN_PARENTHESIS, CLOSE_PARENTHESIS, OPEN_BRACKET, CLOSE_BRACKET, OPEN_CURLY_BRACE, CLOSE_CURLY_BRACE,
    GREATER_THAN, LESS_THAN, SEMICOLON, DOUBLE_COLON, COLON, DOT, COMMA,
    COMPARISON, EQUAL, NOT_EQUAL,
    PLUS, MINUS, TIMES, DIVISION, MODULUS,
    AND, NOT;

%left CLOSE_PARENTHESIS;
%left TIMES;
%left PLUS;

%embed {:
  private boolean good;
          
  public boolean isGood() { return good; }
          
  protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception {
    super.recoverFromError(token, in);
    good = false;
  }
:};

%init {: good = true; :};

%typeof Prog = "Node";
%typeof Def = "Node";
%typeof Data = "Node";
%typeof Decl = "Node";
%typeof Fun = "Node";
%typeof Params = "Node";
%typeof Type = "Node";
%typeof BType = "Node";
%typeof Cmd = "Node";
%typeof Exp = "Node";
%typeof LValue = "Node";
%typeof Exps = "Node";

%goal Prog;

Prog = Def.def*      {: return def; :}
     ;

Def = Data.data      {: return ; :}
    | Fun.fun        {: return ; :}
    ;

Data = DATA TYPE_NAME.typeName OPEN_CURLY_BRACE Decl.decl* CLOSE_CURLY_BRACE      {: return ; :}
     ;

Decl = ID.id DOUBLE_COLON Type SEMICOLON       {: return ; :}
     ;

Fun = ID.id OPEN_PARENTHESIS Params.params? CLOSE_PARENTHESIS TypeDef.typeDef? OPEN_CURLY_BRACE Cmd.cmd* CLOSE_CURLY_BRACE     {: return ; :}
    ;

TypeDef = COLON Type TypeList*
        ;

TypeList = COMMA Type
         ;

Params = ID.id DOUBLE_COLON Type.type ParamsTypeList.paramsTypeList*    {: return ; :}
       ;

ParamsTypeList = COMMA ID DOUBLE_COLON Type
               ;

Type = Type.type OPEN_BRACKET CLOSE_BRACKET   {: return ; :}
     | BType.bType    {: return ; :}
     ;

BType = TYPE_NAME.typeName  {: return ; :}
      ;

Cmd = OPEN_CURLY_BRACE Cmd.cmd* CLOSE_CURLY_BRACE    {: return ; :}
    | IF OPEN_PARENTHESIS Exp.exp CLOSE_PARENTHESIS Cmd.cmd    {: return ; :}
    | IF OPEN_PARENTHESIS Exp.exp CLOSE_PARENTHESIS Cmd.cmd ELSE Cmd.cmd    {: return ; :}
    | ITERATE OPEN_PARENTHESIS Exp.exp CLOSE_PARENTHESIS Cmd.cmd    {: return ; :}
    | READ LValue.lValue SEMICOLON    {: return ; :}
    | PRINT Exp.exp SEMICOLON    {: return ; :}
    | RETURN Exp.exp ExpList* SEMICOLON    {: return ; :}
    | LValue.lValue EQUAL Exp.exp SEMICOLON    {: return ; :}
    | ID OPEN_PARENTHESIS Exps.exps? CLOSE_PARENTHESIS ReturnParams.returnParams? SEMICOLON    {: return ; :}
    ;

ExpList = COMMA Exp.exp
        ;

LValueList = COMMA LValue.lvalue
           ;

ReturnParams = LESS_THAN LValue.lvalue LValueList* GREATER_THAN
             ;

Exp = Exp.expLeft AND Exp.expRight    {: return ; :}
    | Exp.expLeft LESS_THAN Exp.expRight    {: return ; :}
    | Exp.expLeft EQUAL Exp.expRight    {: return ; :}
    | Exp.expLeft COMPARISON Exp.expRight    {: return ; :}
    | Exp.expLeft NOT_EQUAL Exp.expRight    {: return ; :}
    | Exp.expLeft PLUS Exp.expRight    {: return ; :}
    | Exp.expLeft MINUS Exp.expRight    {: return ; :}
    | Exp.expLeft TIMES Exp.expRight    {: return ; :}
    | Exp.expLeft DIVISION Exp.expRight    {: return ; :}
    | Exp.expLeft MODULUS Exp.expRight    {: return ; :}
    | NOT Exp.exp    {: return ; :}
    | MINUS Exp.expRight    {: return ; :}
    | BOOLEAN.boolean    {: return ; :}
    | NULL    {: return ; :}
    | INT.int    {: return ; :}
    | FLOAT.float    {: return ; :}
    | CHAR.char    {: return ; :}
    | LValue.lValue    {: return ; :}
    | OPEN_PARENTHESIS Exp.exp CLOSE_PARENTHESIS    {: return ; :}
    | NEW Type.type VectorDef.vectorDef?    {: return ; :}
    | ID OPEN_PARENTHESIS Exps.exps? CLOSE_PARENTHESIS OPEN_BRACKET Exp.exp CLOSE_BRACKET    {: return ; :}
    ;

VectorDef = OPEN_BRACKET Exp.exp CLOSE_BRACKET
          ;

LValue = ID.id   {: return ; :}
       | LValue.lValue OPEN_BRACKET Exp.exp CLOSE_BRACKET  {: return ; :}
       | LValue.lValue DOT ID.id   {: return ; :}
       ;

Exps = Exp.exp ExpList.expList*     {: return ; :}
     ;

ExpList = COMMA Exp.exp
        ;